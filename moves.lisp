(in-package #:2048-ai)

(defun squash-left! (board)
  (iter (for y from 0 to 3)
        (iter (for x from 1 to 3)
              (for p-x previous x initially 0)
              (if (eql (board-ref board x y)
                       (board-ref board p-x y))
                  (progn
                    (setf (board-ref board x y) 0)
                    (setf (board-ref board p-x y) (* 2 (board-ref board p-x y)))))))
  board)

(defun slide-left! (board)
  (iter (for y from 0 to 3)
        (iter (for x from 0 to 3)
              (when (not (eql (board-ref board x y) 0))
                (collect (board-ref board x y) into nums))
              (finally (iter (for i from 0 to 3)
                             (setf (board-ref board i y) (or (nth i nums) 0)))))))

(defun move-left (old-board)
  (let ((board (copy-board old-board)))
    (slide-left! board)
    (squash-left! board)
    (slide-left! board)
    board))

(defun squash-right! (board)
  (iter (for y from 0 to 3)
        (iter (for x from 2 downto 0)
              (for p-x previous x initially 3)
              (if (eql (board-ref board x y)
                       (board-ref board p-x y))
                  (progn
                    (setf (board-ref board x y) 0)
                    (setf (board-ref board p-x y) (* 2 (board-ref board p-x y)))))))
  board)

(defun slide-right! (board)
  (iter (for y from 0 to 3)
        (iter (for x from 0 to 3)
              (when (not (eql (board-ref board x y) 0))
                (collect (board-ref board x y) into nums at beginning))
              (finally (iter (for i from 0 to 3)
                             (setf (board-ref board (- 3 i) y) (or (nth i nums) 0)))))))

(defun move-right (old-board)
  (let ((board (copy-board old-board)))
    (slide-right! board)
    (squash-right! board)
    (slide-right! board)
    board))

(defun squash-up! (board)
  (iter (for x from 0 to 3)
        (iter (for y from 1 to 3)
              (for p-y previous y initially 0)
              (if (eql (board-ref board x y)
                       (board-ref board x p-y))
                  (progn
                    (setf (board-ref board x y) 0)
                    (setf (board-ref board x p-y) (* 2 (board-ref board x p-y)))))))
  board)

(defun slide-up! (board)
  (iter (for x from 0 to 3)
        (iter (for y from 0 to 3)
              (when (not (eql (board-ref board x y) 0))
                (collect (board-ref board x y) into nums))
              (finally (iter (for i from 0 to 3)
                             (setf (board-ref board x i) (or (nth i nums) 0)))))))

(defun move-up (old-board)
  (let ((board (copy-board old-board)))
    (slide-up! board)
    (squash-up! board)
    (slide-up! board)
    board))

(defun squash-down! (board)
  (iter (for x from 0 to 3)
        (iter (for y from 2 downto 0)
              (for p-y previous y initially 3)
              (if (eql (board-ref board x y)
                       (board-ref board x p-y))
                  (progn
                    (setf (board-ref board x y) 0)
                    (setf (board-ref board x p-y) (* 2 (board-ref board x p-y)))))))
  board)

(defun slide-down! (board)
  (iter (for x from 0 to 3)
        (iter (for y from 0 to 3)
              (when (not (eql (board-ref board x y) 0))
                (collect (board-ref board x y) into nums at beginning))
              (finally (iter (for i from 0 to 3)
                             (setf (board-ref board x (- 3 i)) (or (nth i nums) 0)))))))

(defun move-down (old-board)
  (let ((board (copy-board old-board)))
    (slide-down! board)
    (squash-down! board)
    (slide-down! board)
    board))

(defun move (board move)
  (funcall (move-func-for move) board))

(defun move-func-for (move)
  (ecase move
      (left #'move-left)
      (right #'move-right)
      (up #'move-up)
      (down #'move-down)))